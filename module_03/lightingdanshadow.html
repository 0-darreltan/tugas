<!DOCTYPE html>
<html lang="id">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Objek Melayang Tanpa Lighting & Shadow - Three.js</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #202530;
            /* Warna background bisa disesuaikan agar objek terlihat jelas */
        }

        canvas {
            display: block;
        }
    </style>
</head>

<body>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, controls;
        let plane, cube, sphere, pyramid;
        let objectBasicMaterial, planeBasicMaterial; // Kita akan gunakan MeshBasicMaterial

        const texturePath = "texture.jpeg"; // Pastikan file ini ada atau gunakan URL
        // Contoh placeholder jika texture.jpeg tidak ada:
        // const texturePath = "https://threejs.org/examples/textures/uv_grid_opengl.jpg";


        function init() {
            // 1. Scene
            scene = new THREE.Scene();
            // scene.background = new THREE.Color(0xffffff); // Opsional: background terang agar objek lebih terlihat

            // 2. Camera
            const fov = 50;
            const aspect = window.innerWidth / window.innerHeight;
            const near = 0.1;
            const far = 1000;
            camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
            camera.position.set(0, 8, 18);
            camera.lookAt(0, 1, 0);

            // 3. Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            // === SHADOW MAP DINONAKTIFKAN ===
            // renderer.shadowMap.enabled = true;
            // renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            // 4. Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.target.set(0, 1, 0);

            // 5. Texture Loader
            const textureLoader = new THREE.TextureLoader();
            textureLoader.load(
                texturePath,
                function (loadedTexture) {
                    console.log("Tekstur BERHASIL dimuat.");
                    // Untuk MeshBasicMaterial, ClampToEdgeWrapping biasanya sudah cukup
                    loadedTexture.wrapS = THREE.ClampToEdgeWrapping;
                    loadedTexture.wrapT = THREE.ClampToEdgeWrapping;
                    loadedTexture.needsUpdate = true;

                    // Material untuk Kubus, Bola, dan Piramida
                    objectBasicMaterial = new THREE.MeshBasicMaterial({
                        map: loadedTexture.clone() // Clone agar bisa dimodifikasi terpisah jika perlu
                    });
                    objectBasicMaterial.map.needsUpdate = true;

                    if (sphere) sphere.material = objectBasicMaterial;
                    if (cube) cube.material = objectBasicMaterial;
                    if (pyramid) pyramid.material = objectBasicMaterial;

                    // Material untuk Plane
                    const planeTexture = loadedTexture.clone();
                    // Jika ingin plane mengulang tekstur:
                    // planeTexture.wrapS = THREE.RepeatWrapping;
                    // planeTexture.wrapT = THREE.RepeatWrapping;
                    // planeTexture.repeat.set(10, 10);
                    // planeTexture.needsUpdate = true;

                    planeBasicMaterial = new THREE.MeshBasicMaterial({
                        map: planeTexture,
                        side: THREE.DoubleSide // Agar terlihat dari bawah juga jika kamera bergerak
                    });
                    if (plane) plane.material = planeBasicMaterial;

                    console.log("Material Basic diterapkan.");
                },
                (xhr) => console.log(`Tekstur: ${(xhr.loaded / xhr.total * 100)}% loaded`),
                (error) => {
                    console.error("Gagal memuat tekstur:", error);
                    // Fallback jika tekstur gagal, objek akan menggunakan warna material placeholder
                    if (sphere) sphere.material.color.set(0xff00ff);
                    if (cube) cube.material.color.set(0x00ff00);
                    if (pyramid) pyramid.material.color.set(0x0000ff);
                    if (plane) plane.material.color.set(0x888888);
                }
            );

            // 6. Geometries and Meshes (dengan material placeholder awal)

            // PLANE (LANTAI)
            const planeSize = 30;
            const planeGeometry = new THREE.PlaneGeometry(planeSize, planeSize);
            // Material placeholder awal
            plane = new THREE.Mesh(planeGeometry, new THREE.MeshBasicMaterial({ color: 0x666666, side: THREE.DoubleSide, wireframe: true }));
            plane.rotation.x = -Math.PI / 2;
            plane.position.y = 0;
            // plane.receiveShadow = true; // Tidak relevan lagi
            scene.add(plane);

            const floatingHeightBase = 2.5;

            // KUBUS
            const cubeSideLength = 1.8;
            const cubeGeometry = new THREE.BoxGeometry(cubeSideLength, cubeSideLength, cubeSideLength);
            cube = new THREE.Mesh(cubeGeometry, new THREE.MeshBasicMaterial({ color: 0x808080, wireframe: true }));
            cube.position.set(-4, floatingHeightBase + cubeSideLength / 2, 0);
            // cube.castShadow = true;    // Tidak relevan lagi
            // cube.receiveShadow = true; // Tidak relevan lagi
            scene.add(cube);

            // BOLA
            const sphereRadius = 1.5;
            const sphereGeometry = new THREE.SphereGeometry(sphereRadius, 64, 32);
            sphere = new THREE.Mesh(sphereGeometry, new THREE.MeshBasicMaterial({ color: 0xff00cc, wireframe: true }));
            sphere.position.set(0, floatingHeightBase + sphereRadius, 0);
            // sphere.castShadow = true;    // Tidak relevan lagi
            // sphere.receiveShadow = true; // Tidak relevan lagi
            scene.add(sphere);

            // PIRAMIDA
            const pyramidBaseRadius = 1.2;
            const pyramidHeight = 2.5;
            const pyramidGeometry = new THREE.ConeGeometry(pyramidBaseRadius, pyramidHeight, 4);
            pyramid = new THREE.Mesh(pyramidGeometry, new THREE.MeshBasicMaterial({ color: 0x808080, wireframe: true }));
            pyramid.position.set(4, floatingHeightBase + pyramidHeight / 2, 0);
            // pyramid.castShadow = true;    // Tidak relevan lagi
            // pyramid.receiveShadow = true; // Tidak relevan lagi
            scene.add(pyramid);

            // 7. Lights (SEMUA DIHAPUS/DIKOMENTARI)
            // const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            // scene.add(ambientLight);

            // const hemisphereLight = new THREE.HemisphereLight(0xaaaaff, 0x443322, 0.4);
            // hemisphereLight.position.set(0, 20, 0);
            // scene.add(hemisphereLight);

            // const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            // directionalLight.position.set(10, 15, 10);
            // directionalLight.castShadow = true;
            // scene.add(directionalLight);

            // directionalLight.shadow.mapSize.width = 2048;
            // directionalLight.shadow.mapSize.height = 2048;
            // directionalLight.shadow.camera.near = 0.5;
            // directionalLight.shadow.camera.far = 50;
            // directionalLight.shadow.camera.left = -15;
            // directionalLight.shadow.camera.right = 15;
            // directionalLight.shadow.camera.top = 15;
            // directionalLight.shadow.camera.bottom = -15;
            // directionalLight.shadow.bias = -0.001;

            // const shadowCamHelper = new THREE.CameraHelper(directionalLight.shadow.camera);
            // scene.add(shadowCamHelper);
            // const dirLightHelper = new THREE.DirectionalLightHelper(directionalLight, 1);
            // scene.add(dirLightHelper);

            window.addEventListener('resize', onWindowResize, false);
            animate();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // Fungsi placeholder texture jika 'texture.jpeg' tidak ada (opsional, untuk testing)
        function createPlaceholderTexture(callback) {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#' + (Math.random() * 0xFFFFFF << 0).toString(16); // Warna random
            ctx.fillRect(0, 0, 128, 128);
            ctx.fillStyle = 'white'; ctx.font = '16px Arial';
            ctx.textAlign = 'center'; ctx.fillText('Tekstur', 64, 64);
            callback(canvas.toDataURL());
        }

        // Cek jika texturePath adalah "texture.jpeg" dan mungkin tidak ada
        if (texturePath === "texture.jpeg") {
            // Untuk memastikan kode berjalan meskipun texture.jpeg tidak ada,
            // Anda bisa meng-uncomment baris berikut untuk menggunakan Data URL placeholder
            // Saya akan membuatnya otomatis agar kode langsung jalan jika 'texture.jpeg' tidak ditemukan
            const img = new Image();
            img.src = texturePath;
            img.onerror = () => {
                console.warn("File 'texture.jpeg' tidak ditemukan. Menggunakan placeholder texture data URL.");
                createPlaceholderTexture(function (dataUrl) {
                    const manager = new THREE.LoadingManager();
                    manager.setURLModifier((url) => {
                        if (url === "texture.jpeg") return dataUrl;
                        return url;
                    });
                    const originalTextureLoader = THREE.DefaultLoadingManager;
                    THREE.DefaultLoadingManager = manager;
                    init();
                    THREE.DefaultLoadingManager = originalTextureLoader;
                });
            };
            img.onload = () => { // Jika texture.jpeg ada
                init();
            }
        } else {
            init(); // Jika texturePath sudah URL atau file yang pasti ada
        }

    </script>

</body>

</html>