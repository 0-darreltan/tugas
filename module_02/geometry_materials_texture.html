<!DOCTYPE html>
<html lang="id">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Objek Melayang dengan Lighting - Three.js</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #202530;
        }

        canvas {
            display: block;
        }
    </style>
</head>

<body>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, controls;
        let plane, cube, sphere, pyramid;
        let sphereEmissiveMaterial, shinyObjectMaterial, planeStandardMaterial;

        const texturePath = "texture.jpeg";

        function init() {
            // 1. Scene
            scene = new THREE.Scene();

            // 2. Camera
            const fov = 50;
            const aspect = window.innerWidth / window.innerHeight;
            const near = 0.1;
            const far = 1000;
            camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
            camera.position.set(0, 7, 15); // Mundur sedikit lagi untuk melihat plane yang lebih besar
            camera.lookAt(0, 1, 0);

            // 3. Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = false; // Tetap tanpa bayangan
            document.body.appendChild(renderer.domElement);

            // 4. Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.target.set(0, 1, 0);

            // 5. Texture Loader
            const textureLoader = new THREE.TextureLoader();
            console.log("Memulai pemuatan tekstur dari:", texturePath);

            textureLoader.load(
                texturePath,
                function (loadedTexture) {
                    console.log("Tekstur BERHASIL dimuat.");

                    // Pengaturan wrap untuk tekstur yang tidak diulang
                    loadedTexture.wrapS = THREE.ClampToEdgeWrapping;
                    loadedTexture.wrapT = THREE.ClampToEdgeWrapping;

                    // --- MATERIAL SPHERE (EMISSIVE TEXTURE, 1x1) ---
                    sphereEmissiveMaterial = new THREE.MeshBasicMaterial({
                        map: loadedTexture.clone() // Clone untuk sphere
                    });
                    sphereEmissiveMaterial.map.needsUpdate = true;
                    if (sphere) sphere.material = sphereEmissiveMaterial;

                    // --- MATERIAL CUBE & PYRAMID (SHINY, 1x1) ---
                    shinyObjectMaterial = new THREE.MeshStandardMaterial({
                        map: loadedTexture.clone(), // Clone untuk shiny objects
                        metalness: 0.85, // Sedikit lebih metalik
                        roughness: 0.15, // Sedikit lebih halus
                    });
                    shinyObjectMaterial.map.needsUpdate = true;
                    if (cube) cube.material = shinyObjectMaterial;
                    if (pyramid) pyramid.material = shinyObjectMaterial;

                    // --- MATERIAL PLANE (STANDARD, 1x1) ---
                    planeStandardMaterial = new THREE.MeshStandardMaterial({
                        map: loadedTexture.clone(), // Clone juga untuk plane
                        metalness: 0.2,  // Plane tidak terlalu metalik
                        roughness: 0.8,  // Plane lebih kasar
                    });
                    planeStandardMaterial.map.needsUpdate = true;
                    if (plane) plane.material = planeStandardMaterial;

                    console.log("Semua material telah diinisialisasi dengan tekstur.");
                },
                (xhr) => console.log(`Tekstur: ${(xhr.loaded / xhr.total * 100)}% loaded`),
                (error) => {
                    console.error("Gagal memuat tekstur:", error);
                    alert("Gagal memuat tekstur. Objek akan menggunakan warna fallback.");
                    // Fallback sederhana
                    if (sphere) sphere.material.color.setHex(0xff00ff);
                    if (cube) cube.material.color.setHex(0x888888);
                    if (pyramid) pyramid.material.color.setHex(0x888888);
                    if (plane) plane.material.color.setHex(0x777777);
                }
            );

            // 6. Geometries and Meshes (dengan material placeholder)

            // PLANE (LANTAI) - DIPERBESAR
            const planeSize = 30; // Ukuran plane jauh lebih besar
            const planeGeometry = new THREE.PlaneGeometry(planeSize, planeSize);
            plane = new THREE.Mesh(planeGeometry, new THREE.MeshStandardMaterial({ color: 0x666666, side: THREE.DoubleSide }));
            plane.rotation.x = -Math.PI / 2;
            plane.position.y = 0;
            scene.add(plane);

            // --- OBJEK MELAYANG ---
            const floatingHeightBase = 2.5;

            // KUBUS
            const cubeSideLength = 1.8; // Sedikit lebih besar
            const cubeGeometry = new THREE.BoxGeometry(cubeSideLength, cubeSideLength, cubeSideLength);
            cube = new THREE.Mesh(cubeGeometry, new THREE.MeshStandardMaterial({ color: 0x808080 }));
            cube.position.set(-4, floatingHeightBase + cubeSideLength / 2, 0);
            scene.add(cube);

            // BOLA
            const sphereRadius = 1.5; // Sedikit lebih besar
            const sphereGeometry = new THREE.SphereGeometry(sphereRadius, 64, 32);
            sphere = new THREE.Mesh(sphereGeometry, new THREE.MeshBasicMaterial({ color: 0xff00cc }));
            sphere.position.set(0, floatingHeightBase + sphereRadius, 0);
            scene.add(sphere);

            // PIRAMIDA
            const pyramidBaseRadius = 1.2; // Sedikit lebih besar
            const pyramidHeight = 2.5;   // Sedikit lebih besar
            const pyramidGeometry = new THREE.ConeGeometry(pyramidBaseRadius, pyramidHeight, 4);
            pyramid = new THREE.Mesh(pyramidGeometry, new THREE.MeshStandardMaterial({ color: 0x808080 }));
            pyramid.position.set(4, floatingHeightBase + pyramidHeight / 2, 0);
            scene.add(pyramid);

            // 7. Lights
            // Ambient light untuk mengisi area gelap
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); // Intensitas ambient sedikit diturunkan
            scene.add(ambientLight);

            // Directional light untuk memberikan arah dan highlight
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9); // Intensitas directional light cukup kuat
            directionalLight.position.set(5, 10, 7); // Atur posisi sumber cahaya
            directionalLight.target = scene; // Arahkan ke pusat scene (atau objek tertentu jika perlu)
            scene.add(directionalLight);
            // Opsional: helper untuk melihat arah directional light
            // const dirLightHelper = new THREE.DirectionalLightHelper(directionalLight, 1);
            // scene.add(dirLightHelper);

            window.addEventListener('resize', onWindowResize, false);
            animate();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        init();
    </script>

</body>

</html>